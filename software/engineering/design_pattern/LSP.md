# Liskov Substitution Principle (Liskov 替換原則)

---

## Liskov 替換原則的介紹、解釋及優點

---

`若對型態 S 的每一個物件 o1 ，都存在一個型態為 T 的物件 o2 ，使得在所有針對 T 編寫的程式 P 中，用 o1 替換 o2 後，程式 P 的行為功能不變，則 S 是 T 的子型態。`

_**完全看不懂。**_

### 解釋

---

- 首先先搞清楚對象是牽涉到『繼承』的類別、『實作』的介面，父類別延伸出子類別、介面延伸出實作。
- 一種解釋是：『子類別』必須能完全取代『父類別』、或者『實作』必須能取代『介面』，取代後『行為』、功能不變。
- 另一種解釋是：延伸物必須遵循源頭的功能，不能自創新邏輯、修改原邏輯。
- 舉一個實例是：首先我們有一個『狗』這個物件，其中狗定義了『吃』這個介面，接下來我們延伸『吃』出兩個實作：吃且很大口、吃且很小口，這時出現了一隻『狗』，它是實物(instance)、為免混淆它就先叫阿呆，阿呆不論是調用『吃且很大口』或者是『吃且很小口』，阿呆都是在『吃』，行為並沒有改變，故『吃且很大口』、『吃且很小口』都是『吃』的子型態，我們用『吃且很大口』替換掉『吃』後，依然能夠宣告一隻會『吃』的『狗』，『狗』可以是阿呆、小黑、大白等等都行。

### 優點

---

- 並不知道怎麼解釋，我們直接看缺點。

## 違反後的缺點？

---

- 先舉一個實例，我們的認知中：正方形是一種長方形，聽起來很合理，畢竟長方形有的規範、基本上正方形也有，那因為正方形被算作長方形的一種、於是我們就讓『正方形』這個物件從已建立的『長方形』這個物件延伸出來。接著我們想要調用面積，調用長方形的面積算法、正方形的面積算法都行嗎？很明顯是不可行的，也就是說這個並沒有符合 Liskov 替換原則。那要怎麼辦？判斷是正方形還是長方形、再依其調用面積算法，那今天假定同樣情況有一百個形狀，我不就要判斷一百個形狀、各自調用各自的方法？那幹嘛還要繼承？
- 依照上面的例子，我可以不要判斷一百種形狀嗎？可以！把形狀和其對應方法結合成 key-pair(map, key-value)，用資料庫記下來，會比加一個形狀就改一次程式碼好(畢竟有可能產生 bug 或是再違反其他原則、製造更多風險)，但很明顯也不是什麼好事，增加了時間成本、開發成本、空間成本還有維護成本。
